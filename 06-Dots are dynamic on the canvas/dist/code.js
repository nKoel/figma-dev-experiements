/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./code.js":
/*!*****************!*\
  !*** ./code.js ***!
  \*****************/
/***/ (() => {

eval("figma.showUI(__html__);\n\n// Initialize variables\nlet dotIds = new Set();\nlet groups = {};\n\n// Load saved dot IDs\nfunction loadDotIds() {\n    const savedDotIds = figma.currentPage.getPluginData(\"dotIds\");\n    if (savedDotIds) {\n        dotIds = new Set(JSON.parse(savedDotIds));\n    }\n}\n\n// Save dot IDs\nfunction saveDotIds() {\n    figma.currentPage.setPluginData(\"dotIds\", JSON.stringify(Array.from(dotIds)));\n}\n\n// Load saved groups\nfunction loadGroups() {\n    const savedGroups = figma.currentPage.getPluginData(\"groups\");\n    if (savedGroups) {\n        try {\n            groups = JSON.parse(savedGroups);\n            console.log(\"Loaded groups:\", groups);\n        } catch (error) {\n            console.error(\"Error parsing saved groups, initializing default:\", error);\n            initializeDefaultGroups();\n        }\n    } else {\n        initializeDefaultGroups();\n    }\n}\n\n// New helper function to initialize default groups\nfunction initializeDefaultGroups() {\n    groups = {\n        \"group-1\": { name: \"Group 1\", dotCount: 0 },\n        \"group-2\": { name: \"Group 2\", dotCount: 0 }\n    };\n    saveGroups();\n}\n\n// Save groups\nfunction saveGroups() {\n    figma.currentPage.setPluginData(\"groups\", JSON.stringify(groups));\n    console.log(\"Saved groups:\", groups);\n}\n\n// Update dot count in UI\nfunction updateDotCount() {\n    figma.ui.postMessage({ \n        type: 'UPDATE_COUNT', \n        count: dotIds.size,\n        groups: groups // Make sure we're sending the groups data\n    });\n    console.log(\"Sending update to UI:\", { count: dotIds.size, groups: groups }); // Debug log\n}\n\n// Create a new dot\nasync function createDot(groupId = \"group-1\") {\n    try {\n        const frame = figma.createFrame();\n        frame.name = `Dot ${dotIds.size + 1}`;\n        frame.resize(100, 100);\n        frame.x = figma.viewport.center.x;\n        frame.y = figma.viewport.center.y;\n        frame.cornerRadius = 100;\n        frame.fills = [{ type: 'SOLID', color: { r: 0, g: 0, b: 1 } }];\n        \n        // Wait for the frame to be fully created\n        await new Promise(resolve => setTimeout(resolve, 0));\n        \n        frame.setPluginData(\"isDot\", \"true\");\n        frame.setPluginData(\"groupId\", groupId);``\n\n        const text = figma.createText();\n        await figma.loadFontAsync({ family: \"Inter\", style: \"Regular\" });\n        text.characters = (dotIds.size + 1).toString();\n        text.fontSize = 24;\n        text.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];\n        \n        frame.appendChild(text);\n        text.x = (frame.width - text.width) / 2;\n        text.y = (frame.height - text.height) / 2;\n\n        figma.currentPage.appendChild(frame);\n        dotIds.add(frame.id);\n        saveDotIds();\n\n        await syncGroupCounts();\n        \n        return frame;\n    } catch (error) {\n        console.error(\"Error in createDot:\", error);\n        throw error;\n    }\n}\n\n// Handle messages from UI\nfigma.ui.onmessage = async (msg) => {\n    if (msg.type === \"ADD_DOT\") {\n        try {\n            const groupId = msg.groupId || \"group-1\";\n            await createDot(groupId);\n            await reorderDots();\n            updateDotCount();\n        } catch (error) {\n            console.error(\"Error adding dot:\", error);\n        }\n    } else if (msg.type === \"SAVE_GROUPS\") {\n        groups = msg.groups;\n        saveGroups();\n        updateDotCount();\n    } else if (msg.type === \"DELETE_GROUP\") {\n        // Find and delete all dots belonging to the group\n        const dotsToDelete = figma.currentPage.findAll(node => \n            node.type === \"FRAME\" && \n            node.getPluginData(\"isDot\") === \"true\" &&\n            node.getPluginData(\"groupId\") === msg.groupId\n        );\n        \n        // Remove the dots from our tracking set and delete them\n        dotsToDelete.forEach(dot => {\n            dotIds.delete(dot.id);\n            dot.remove();\n        });\n        \n        // Save the updated state\n        saveDotIds();\n        groups = msg.groups;\n        saveGroups();\n        \n        // Make sure we update the counts\n        await syncGroupCounts();\n        updateDotCount();  // This will update the \"You've got x Dots\" text\n    }\n};\n\n// Setup event listener for document changes\nfunction setupEventListener() {\n    figma.on(\"documentchange\", async (event) => {\n        try {\n            let dotCountChanged = false;\n            let needsReorder = false;\n            \n            for (const change of event.documentChanges) {\n                if (change.type === \"DELETE\") {\n                    if (dotIds.has(change.node.id)) {\n                        dotIds.delete(change.node.id);\n                        dotCountChanged = true;\n                        needsReorder = true;\n                    }\n                } else if (change.type === \"CREATE\") {\n                    const node = change.node;\n                    if (node.type === \"FRAME\" && node.getPluginData(\"isDot\") === \"true\") {\n                        await new Promise(resolve => setTimeout(resolve, 0)); // Give time for node to be fully created\n                        dotIds.add(node.id);\n                        const groupId = node.getPluginData(\"groupId\") || \"group-1\";\n                        node.setPluginData(\"groupId\", groupId);\n                        dotCountChanged = true;\n                        needsReorder = true;\n                    }\n                }\n            }\n\n            if (needsReorder) {\n                await reorderDots();\n                saveDotIds();\n                await syncGroupCounts();\n            } else if (dotCountChanged) {\n                saveDotIds();\n                await syncGroupCounts();\n            }\n        } catch (error) {\n            console.log(\"Handled error in document change:\", error);\n        }\n    });\n}\n\n// Sync group counts with actual dots\nasync function syncGroupCounts() {\n    // Find all dots on the canvas\n    const allDots = figma.currentPage.findAll(node => \n        node.type === \"FRAME\" && node.getPluginData(\"isDot\") === \"true\"\n    );\n    \n    // Reset all group counts\n    for (const groupId in groups) {\n        groups[groupId].dotCount = 0;\n    }\n    \n    // Count dots per group and log each dot's group\n    for (const dot of allDots) {\n        const groupId = dot.getPluginData(\"groupId\") || \"group-1\";\n        console.log(`Dot ${dot.name} belongs to group: ${groupId}`); // Debug log\n        \n        if (groups[groupId]) {\n            groups[groupId].dotCount += 1;\n            console.log(`Incremented count for ${groupId} to ${groups[groupId].dotCount}`); // Debug log\n        }\n    }\n    \n    // Log final group state\n    console.log(\"Final group state:\", JSON.stringify(groups, null, 2));\n    \n    saveGroups();\n    updateDotCount();\n}\n\n// Initialize plugin\nasync function initializePlugin() {\n    console.log(\"Initializing plugin...\");\n    await figma.loadAllPagesAsync();\n    loadGroups(); // Load groups first\n    loadDotIds();\n    await syncGroupCounts(); // This will handle counting existing dots\n    setupEventListener();\n    console.log(\"Plugin initialization complete\");\n}\n\n// Start the plugin\ninitializePlugin();\nfigma.showUI(__html__);\n\n// Reorder dots and update their numbers\nasync function reorderDots() {\n    // First, organize dots by group\n    const dotsByGroup = {};\n    \n    const allDots = figma.currentPage.findAll(node => \n        node.type === \"FRAME\" && node.getPluginData(\"isDot\") === \"true\"\n    );\n\n    // Sort dots into their groups\n    allDots.forEach(dot => {\n        const groupId = dot.getPluginData(\"groupId\") || \"group-1\";\n        if (!dotsByGroup[groupId]) {\n            dotsByGroup[groupId] = [];\n        }\n        dotsByGroup[groupId].push(dot);\n    });\n\n    // Update numbers for each group separately\n    for (const groupId in dotsByGroup) {\n        const groupDots = dotsByGroup[groupId];\n        \n        for (let i = 0; i < groupDots.length; i++) {\n            const dot = groupDots[i];\n            const newNumber = i + 1;\n            \n            dot.name = `${groups[groupId].name} Dot ${newNumber}`;\n            \n            const textNode = dot.findOne(node => node.type === \"TEXT\");\n            if (textNode) {\n                await figma.loadFontAsync(textNode.fontName);\n                textNode.characters = newNumber.toString();\n                textNode.x = (dot.width - textNode.width) / 2;\n                textNode.y = (dot.height - textNode.height) / 2;\n            }\n        }\n    }\n}\n\n//# sourceURL=webpack://figma-dots-plugin/./code.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./code.js"]();
/******/ 	
/******/ })()
;