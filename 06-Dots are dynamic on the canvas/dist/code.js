/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./code.js":
/*!*****************!*\
  !*** ./code.js ***!
  \*****************/
/***/ (() => {

eval("figma.showUI(__html__);\n\n// When plugin starts, use let variable\nlet dotIds = new Set(); // Creates empty Set: {}\n\n// Function to update the UI with the current dot count\nfunction updateDotCount() {\n    // First, Get / read and parse the stored dotCount - NB: the key \"dotCount\" must \n    // match the setter key to work\n    const dotCount = parseInt(figma.currentPage.getPluginData(\"dotCount\") || \"0\");\n\n    // Send message to UI\n    figma.ui.postMessage({ type: 'UPDATE_COUNT', count: dotCount });\n    console.log(\"Current dot count:\", dotCount);\n}\n\n// Function to increment the dot count\nfunction incrementDotCount() {\n\n    // First, Get / read and parse the stored dotCount\n    const currentCount = parseInt(figma.currentPage.getPluginData(\"dotCount\") || \"0\");\n\n    // Then, set the dotCount to the currentCount +1 one and convert to string\n    // The key (first argument) = label, the value (2nd argument) = value\n    figma.currentPage.setPluginData(\"dotCount\", (currentCount + 1).toString());\n\n    // Finally, run the function to update the dot count\n    updateDotCount();\n}\n\n// Function to decrement the dot count\nfunction decrementDotCount() {\n    const currentCount = parseInt(figma.currentPage.getPluginData(\"dotCount\") || \"0\");\n    if (currentCount > 0) {\n        figma.currentPage.setPluginData(\"dotCount\", (currentCount - 1).toString());\n        updateDotCount();\n    }\n}\n\n// Function to create a new dot\nasync function createDot() {\n    // Get current dot count to use as the number\n    const currentCount = parseInt(figma.currentPage.getPluginData(\"dotCount\") || \"0\") + 1;\n\n    // Define the object type to Frame\n    const frame = figma.createFrame();\n    frame.name = `Dot ${currentCount}`; // Frame name is correct\n\n    // Styling the frame\n    frame.resize(100, 100);\n    frame.x = figma.viewport.center.x;\n    frame.y = figma.viewport.center.y;\n    frame.cornerRadius = 100;\n    frame.fills = [{ type: 'SOLID', color: { r: 0, g: 0, b: 1 } }];\n\n    // Marking the frame as a Dot\n    frame.setPluginData(\"isDot\", \"true\");\n\n    // Create and style text layer\n    const text = figma.createText();\n    await figma.loadFontAsync({ family: \"Inter\", style: \"Regular\" });\n    \n    // Use currentCount for the text content\n    text.characters = currentCount.toString();\n    text.fontSize = 24;\n    text.fontName = { family: \"Inter\", style: \"Regular\" };\n    text.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];\n    \n    // Add text to frame and center it\n    frame.appendChild(text);\n    text.x = (frame.width - text.width) / 2;\n    text.y = (frame.height - text.height) / 2;\n\n    // Add to page\n    figma.currentPage.appendChild(frame);\n\n    dotIds.add(frame.id);\n    saveDotIds();\n        \n    return frame;\n}\n\n// ADD DOT FROM UI\nfigma.ui.onmessage = async (msg) => {\n    if (msg.type === \"ADD_DOT\") {\n        try {\n            const newDot = await createDot();\n            figma.notify(\"Dot added successfully\");\n\n            // why put 'error' here\n        } catch (error) {\n\n            // What's error.message? \n            figma.notify(\"Error adding dot: \" + error.message);\n        }\n    }\n};\n\n// Function to save dotIds to plugin data\nfunction saveDotIds() {\n\n    figma.currentPage.setPluginData(\"dotIds\", JSON.stringify(Array.from(dotIds)));\n}\n\n// Function to load dotIds from plugin data\n\n// Will load ID's to check if any previous dots have been made. \nfunction loadDotIds() {\n    const savedDotIds = figma.currentPage.getPluginData(\"dotIds\"); // Gets saved IDs\n    if (savedDotIds) {\n        // Replaces empty Set with new Set containing saved IDs\n        dotIds = new Set(JSON.parse(savedDotIds));\n    }\n}\n\n// Function to count existing dots on the current page\nasync function countExistingDots() {\n    // 1. Find all frames marked as dots\n    const allDots = figma.currentPage.findAll(node => node.type === \"FRAME\" && node.getPluginData(\"isDot\") === \"true\");\n\n    // 2. Create new Set with just the IDs\n    dotIds = new Set(allDots.map(dot => dot.id));\n\n    // 3. Save to permanent storage\n    saveDotIds();\n\n    // 4. Update the count\n    figma.currentPage.setPluginData(\"dotCount\", allDots.length.toString());\n    \n    // 5. Update text content for all dots\n    for (let i = 0; i < allDots.length; i++) {\n        const dot = allDots[i];\n        const textNode = dot.findOne(node => node.type === \"TEXT\");\n        if (textNode) {\n            await figma.loadFontAsync(textNode.fontName);\n            textNode.characters = (i + 1).toString();\n            // Recenter the text\n            textNode.x = (dot.width - textNode.width) / 2;\n            textNode.y = (dot.height - textNode.height) / 2;\n        }\n    }\n\n    updateDotCount();\n}\n\n// Function to reorder and update all dot numbers\nasync function reorderDots() {\n    // Find all dots on the page in their current order\n    const allDots = figma.currentPage.findAll(node => \n        node.type === \"FRAME\" && node.getPluginData(\"isDot\") === \"true\"\n    );\n\n    // Update each dot with its new number\n    for (let i = 0; i < allDots.length; i++) {\n        const dot = allDots[i];\n        const newNumber = i + 1;\n        \n        // Update frame name\n        dot.name = `Dot ${newNumber}`;\n        \n        // Update text content\n        const textNode = dot.findOne(node => node.type === \"TEXT\");\n        if (textNode) {\n            await figma.loadFontAsync(textNode.fontName);\n            textNode.characters = newNumber.toString();\n            // Recenter the text\n            textNode.x = (dot.width - textNode.width) / 2;\n            textNode.y = (dot.height - textNode.height) / 2;\n        }\n    }\n\n    // Update the total count\n    figma.currentPage.setPluginData(\"dotCount\", allDots.length.toString());\n    updateDotCount();\n}\n\n// Function to set up the document change event listener\nfunction setupEventListener() {\n    figma.on(\"documentchange\", (event) => {\n        let dotCountChanged = false;\n        let newDots = [];\n        let deletionOccurred = false;\n        \n        for (const change of event.documentChanges) {\n            if (change.type === \"DELETE\") {\n                if (dotIds.has(change.node.id)) {\n                    dotIds.delete(change.node.id);\n                    decrementDotCount();\n                    dotCountChanged = true;\n                    deletionOccurred = true;\n                }\n            } else if (change.type === \"CREATE\") {\n                if (change.node.type === \"FRAME\" && \n                    change.node.parent === figma.currentPage && \n                    change.node.getPluginData(\"isDot\") === \"true\") {\n                    newDots.push(change.node);\n                }\n            }\n        }\n\n        // If any dots were deleted, reorder the remaining ones\n        if (deletionOccurred) {\n            setTimeout(async () => {\n                await reorderDots();\n            }, 0);\n        }\n\n        // Handle new dots\n        if (newDots.length > 0) {\n            setTimeout(async () => {\n                for (const dot of newDots) {\n                    const currentCount = parseInt(figma.currentPage.getPluginData(\"dotCount\") || \"0\") + 1;\n                    dot.name = `Dot ${currentCount}`;\n                    \n                    const textNode = dot.findOne(node => node.type === \"TEXT\");\n                    if (textNode) {\n                        await figma.loadFontAsync(textNode.fontName);\n                        textNode.characters = currentCount.toString();\n                        textNode.x = (dot.width - textNode.width) / 2;\n                        textNode.y = (dot.height - textNode.height) / 2;\n                    }\n\n                    dotIds.add(dot.id);\n                    incrementDotCount();\n                    dotCountChanged = true;\n                }\n\n                if (dotCountChanged) {\n                    saveDotIds();\n                }\n            }, 0);\n        }\n    });\n}\n\n// Initialize the plugin\nasync function initializePlugin() {\n    await figma.loadAllPagesAsync();\n    loadDotIds(); // Load saved dotIds\n    countExistingDots();\n    setupEventListener();\n}\n\n// why is this called twice, seemingly - we have an async of the same name above.\ninitializePlugin();\n\n//# sourceURL=webpack://figma-dots-plugin/./code.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./code.js"]();
/******/ 	
/******/ })()
;